{
  "language": "Solidity",
  "sources": {
    "src/BleepBeats.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"base64-sol/base64.sol\";\n\nimport \"./ERC721/implementations/ERC721.sol\";\nimport \"./ERC721/ERC4494/implementations/UsingERC4494PermitWithDynamicChainId.sol\";\nimport \"./Multicall/UsingMulticall.sol\";\nimport \"./ERC721/implementations/UsingExternalMinter.sol\";\nimport \"./ERC2981/implementations/UsingGlobalRoyalties.sol\";\nimport \"./Guardian/implementations/UsingGuardian.sol\";\nimport \"./TheBleepMachine.sol\";\nimport \"./Utils.sol\";\n\ncontract BleepBeats is\n\tERC721,\n\tUsingERC4494PermitWithDynamicChainId,\n\tUsingMulticall,\n\tUsingGuardian,\n\tUsingExternalMinter,\n\tUsingGlobalRoyalties\n{\n\tTheBleepMachine public immutable theBleepMachine;\n\n\tbytes32 constant HEX = \"0123456789abcdef0000000000000000\";\n\n\t/// @dev Setup the roles\n\t/// @param bleepMachine the Bleep Machine that generate the music\n\t/// @param initialMinterAdmin admin able to set the minter contract.\n\t/// @param initialRoyaltyAdmin admin able to update the royalty receiver and rates.\n\t/// @param initialGuardian guardian able to immortalize rules\n\t/// @param initialRoyaltyReceiver receiver of royalties\n\t/// @param imitialRoyaltyPer10Thousands amount of royalty in 10,000 basis point\n\tconstructor(\n\t\tTheBleepMachine bleepMachine,\n\t\taddress initialGuardian,\n\t\taddress initialMinterAdmin,\n\t\taddress initialRoyaltyReceiver,\n\t\tuint96 imitialRoyaltyPer10Thousands,\n\t\taddress initialRoyaltyAdmin\n\t)\n\t\tUsingExternalMinter(initialMinterAdmin)\n\t\tUsingGlobalRoyalties(initialRoyaltyReceiver, imitialRoyaltyPer10Thousands, initialRoyaltyAdmin)\n\t\tUsingGuardian(initialGuardian)\n\t{\n\t\ttheBleepMachine = bleepMachine;\n\t}\n\n\t/// @notice A descriptive name for a collection of NFTs in this contract.\n\tfunction name() public pure override returns (string memory) {\n\t\treturn \"Bleep Beats\";\n\t}\n\n\t/// @notice An abbreviated name for NFTs in this contract.\n\tfunction symbol() external pure returns (string memory) {\n\t\treturn \"BBS\";\n\t}\n\n\tfunction supportsInterface(bytes4 id)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride(ERC721, UsingERC4494Permit, UsingGlobalRoyalties)\n\t\treturns (bool)\n\t{\n\t\treturn super.supportsInterface(id);\n\t}\n\n\tfunction mint(address to, bytes memory musicBytecode) external {\n\t\tuint256 len = musicBytecode.length;\n\t\trequire(len <= 32, \"TOO_LONG\");\n\t\tuint256 id;\n\t\tassembly {\n\t\t\tid := shr(mul(sub(32, len), 8), mload(add(musicBytecode, 32)))\n\t\t}\n\n\t\t// TODO require(msg.sender == minter, \"NOT_AUTHORIZED\");\n\t\t_mint(id, to);\n\t}\n\n\tfunction tokenURI(uint256 id) external returns (string memory str) {\n\t\tuint256 shift;\n\t\tunchecked {\n\t\t\tshift = (Utils.numLeadingZeroes(id) / 8) * 8;\n\t\t}\n\t\tid = id << shift;\n\t\tbytes memory musicBytecode = new bytes((256 - shift) / 8);\n\t\tassembly {\n\t\t\tmstore(add(musicBytecode, 32), id)\n\t\t}\n\n\t\tstr = string(\n\t\t\tbytes.concat(\n\t\t\t\t'data:application/json,{\"name\":\"The%20Bleep%20Machine\",\"description\":\"The%20Bleep%20Machine%20produces%20music%20from%20EVM%20bytecode.\",\"external_url\":\"TODO\",\"image\":\"',\n\t\t\t\t\"data:image/svg+xml;charset=utf8,<svg%2520xmlns='http://www.w3.org/2000/svg'%2520shape-rendering='crispEdges'%2520width='512'%2520height='512'><style>*{background-color:white}.b{animation:ba%25201s%2520steps(5,start)%2520infinite;-webkit-animation:ba%25201s%2520steps(5,start)%2520infinite;}@keyframes%2520ba{to{visibility: hidden;}}@-webkit-keyframes%2520ba{to{visibility:hidden;}}.b01{ animation-delay:.031s}.b02{animation-delay:.062s}.b03{animation-delay:.093s}.b04{animation-delay:.124s}.b05{animation-delay:.155s}.b06{animation-delay:.186s}.b07{animation-delay:.217s}.b08{animation-delay:.248s}.b09{animation-delay:.279s}.b10{animation-delay:.310s}.b11{animation-delay:.342s}.b12{animation-delay:.373s}.b13{animation-delay:.403s}.b14{animation-delay:.434s}.b15{animation-delay:.465s}.b16{animation-delay:.496s}.b17{animation-delay:.527s}.b18{animation-delay:.558s}.b19{animation-delay:.589s}.b20{animation-delay:.620s}.b21{animation-delay:.651s}.b22{animation-delay:.682s}.b23{animation-delay:.713s}.b24{animation-delay:.744s}.b25{animation-delay:.775s}.b26{animation-delay:.806s}.b27{animation-delay:.837s}.b28{animation-delay:.868s}.b29{animation-delay:.899s}.b30{animation-delay:.930s}.b31{animation-delay:.961s}.b32{animation-delay:.992s}</style><defs><path%2520id='Z'%2520d='M0,0h1v1h-1z'/><use%2520id='0'%2520href='%2523Z'%2520fill='%2523000c24'/><use%2520id='1'%2520href='%2523Z'%2520fill='%25239e0962'/><use%2520id='2'%2520href='%2523Z'%2520fill='%2523ff1c3a'/><use%2520id='3'%2520href='%2523Z'%2520fill='%2523bc0b22'/><use%2520id='4'%2520href='%2523Z'%2520fill='%2523ff991c'/><use%2520id='5'%2520href='%2523Z'%2520fill='%2523c16a00'/><use%2520id='6'%2520href='%2523Z'%2520fill='%2523ffe81c'/><use%2520id='7'%2520href='%2523Z'%2520fill='%25239e8b00'/><use%2520id='8'%2520href='%2523Z'%2520fill='%252323e423'/><use%2520id='9'%2520href='%2523Z'%2520fill='%2523009900'/><use%2520id='a'%2520href='%2523Z'%2520fill='%25231adde0'/><use%2520id='b'%2520href='%2523Z'%2520fill='%2523008789'/><use%2520id='c'%2520href='%2523Z'%2520fill='%25233d97ff'/><use%2520id='d'%2520href='%2523Z'%2520fill='%25233e5ca0'/><use%2520id='e'%2520href='%2523Z'%2520fill='%2523831bf9'/><use%2520id='f'%2520href='%2523Z'%2520fill='%2523522982'/></defs><g%2520transform='scale(64)'><use%2520x='00'%2520class='b%2520b01'%2520y='00'%2520href='%25230'/><use%2520x='01'%2520y='00'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b02'%2520y='00'%2520href='%25230'/><use%2520x='03'%2520y='00'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b03'%2520y='00'%2520href='%25230'/><use%2520x='05'%2520y='00'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b04'%2520y='00'%2520href='%25230'/><use%2520x='07'%2520y='00'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b05'%2520y='01'%2520href='%25230'/><use%2520x='01'%2520y='01'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b06'%2520y='01'%2520href='%25230'/><use%2520x='03'%2520y='01'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b07'%2520y='01'%2520href='%25230'/><use%2520x='05'%2520y='01'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b08'%2520y='01'%2520href='%25230'/><use%2520x='07'%2520y='01'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b09'%2520y='02'%2520href='%25230'/><use%2520x='01'%2520y='02'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b10'%2520y='02'%2520href='%25230'/><use%2520x='03'%2520y='02'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b11'%2520y='02'%2520href='%25230'/><use%2520x='05'%2520y='02'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b12'%2520y='02'%2520href='%25230'/><use%2520x='07'%2520y='02'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b13'%2520y='03'%2520href='%25230'/><use%2520x='01'%2520y='03'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b14'%2520y='03'%2520href='%25230'/><use%2520x='03'%2520y='03'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b15'%2520y='03'%2520href='%25230'/><use%2520x='05'%2520y='03'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b16'%2520y='03'%2520href='%25230'/><use%2520x='07'%2520y='03'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b17'%2520y='04'%2520href='%25230'/><use%2520x='01'%2520y='04'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b18'%2520y='04'%2520href='%25230'/><use%2520x='03'%2520y='04'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b19'%2520y='04'%2520href='%25230'/><use%2520x='05'%2520y='04'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b20'%2520y='04'%2520href='%25230'/><use%2520x='07'%2520y='04'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b21'%2520y='05'%2520href='%25230'/><use%2520x='01'%2520y='05'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b22'%2520y='05'%2520href='%25230'/><use%2520x='03'%2520y='05'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b23'%2520y='05'%2520href='%25230'/><use%2520x='05'%2520y='05'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b24'%2520y='05'%2520href='%25230'/><use%2520x='07'%2520y='05'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b25'%2520y='06'%2520href='%25230'/><use%2520x='01'%2520y='06'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b26'%2520y='06'%2520href='%25230'/><use%2520x='03'%2520y='06'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b27'%2520y='06'%2520href='%25230'/><use%2520x='05'%2520y='06'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b28'%2520y='06'%2520href='%25230'/><use%2520x='07'%2520y='06'%2520href='%25230'/><use%2520x='00'%2520class='b%2520b29'%2520y='07'%2520href='%25230'/><use%2520x='01'%2520y='07'%2520href='%25230'/><use%2520x='02'%2520class='b%2520b30'%2520y='07'%2520href='%25230'/><use%2520x='03'%2520y='07'%2520href='%25230'/><use%2520x='04'%2520class='b%2520b31'%2520y='07'%2520href='%25230'/><use%2520x='05'%2520y='07'%2520href='%25230'/><use%2520x='06'%2520class='b%2520b32'%2520y='07'%2520href='%25230'/><use%2520x='07'%2520y='07'%2520href='%25230'/></g></svg>\",\n\t\t\t\t'\",\"animation_url\":\"data:audio/wav;base64,',\n\t\t\t\tbytes(Base64.encode(theBleepMachine.WAV(musicBytecode, 0, 100000))),\n\t\t\t\t'\"}'\n\t\t\t)\n\t\t);\n\n\t\tfor (uint256 i = 0; i < 64; i += 2) {\n\t\t\tuint256 pre = i / 2;\n\t\t\tuint8 v = uint8(bytes32(id)[pre]);\n\t\t\tbytes(str)[(pre * 22) + 167 + 2327 + i * 46] = HEX[uint8(v >> 4)];\n\t\t\tbytes(str)[(pre * 22) + 167 + 2327 + 46 + i * 46] = HEX[uint8(v & 0x0F)];\n\t\t}\n\t}\n\n\tfunction _mint(uint256 id, address to) internal {\n\t\trequire(to != address(0), \"NOT_TO_ZEROADDRESS\");\n\t\trequire(to != address(this), \"NOT_TO_THIS\");\n\t\taddress owner = _ownerOf(id);\n\t\trequire(owner == address(0), \"ALREADY_CREATED\");\n\t\t_safeTransferFrom(address(0), to, id, \"\");\n\t}\n}\n"
    },
    "src/ERC721/implementations/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"./ImplementingERC721Internal.sol\";\n\nabstract contract ERC721 is IERC721, ImplementingERC721Internal {\n\tusing Address for address;\n\n\tbytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n\tbytes4 internal constant ERC165ID = 0x01ffc9a7;\n\n\tuint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\tuint256 internal constant NOT_OPERATOR_FLAG = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n\tmapping(uint256 => uint256) internal _owners;\n\tmapping(address => uint256) internal _balances;\n\tmapping(address => mapping(address => bool)) internal _operatorsForAll;\n\tmapping(uint256 => address) internal _operators;\n\n\t/// @notice Approve an operator to transfer a specific token on the senders behalf.\n\t/// @param operator The address receiving the approval.\n\t/// @param id The id of the token.\n\tfunction approve(address operator, uint256 id) external override {\n\t\t(address owner, uint256 blockNumber) = _ownerAndBlockNumberOf(id);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\t\trequire(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"UNAUTHORIZED_APPROVAL\");\n\t\t_approveFor(owner, blockNumber, operator, id);\n\t}\n\n\t/// @notice Transfer a token between 2 addresses.\n\t/// @param from The sender of the token.\n\t/// @param to The recipient of the token.\n\t/// @param id The id of the token.\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id\n\t) external override {\n\t\t(address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\t\trequire(owner == from, \"NOT_OWNER\");\n\t\trequire(to != address(0), \"NOT_TO_ZEROADDRESS\");\n\t\trequire(to != address(this), \"NOT_TO_THIS\");\n\t\tif (msg.sender != from) {\n\t\t\trequire(\n\t\t\t\t(operatorEnabled && _operators[id] == msg.sender) || isApprovedForAll(from, msg.sender),\n\t\t\t\t\"UNAUTHORIZED_TRANSFER\"\n\t\t\t);\n\t\t}\n\t\t_transferFrom(from, to, id);\n\t}\n\n\t/// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n\t/// @param from The send of the token.\n\t/// @param to The recipient of the token.\n\t/// @param id The id of the token.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id\n\t) external override {\n\t\tsafeTransferFrom(from, to, id, \"\");\n\t}\n\n\t/// @notice Set the approval for an operator to manage all the tokens of the sender.\n\t/// @param operator The address receiving the approval.\n\t/// @param approved The determination of the approval.\n\tfunction setApprovalForAll(address operator, bool approved) external override {\n\t\t_setApprovalForAll(msg.sender, operator, approved);\n\t}\n\n\t/// @notice Get the number of tokens owned by an address.\n\t/// @param owner The address to look for.\n\t/// @return balance The number of tokens owned by the address.\n\tfunction balanceOf(address owner) public view override returns (uint256 balance) {\n\t\trequire(owner != address(0), \"ZERO_ADDRESS_OWNER\");\n\t\tbalance = _balances[owner];\n\t}\n\n\t/// @notice Get the owner of a token.\n\t/// @param id The id of the token.\n\t/// @return owner The address of the token owner.\n\tfunction ownerOf(uint256 id) external view override returns (address owner) {\n\t\towner = _ownerOf(id);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\t}\n\n\t/// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\n\t/// @param id The id of the token.\n\t/// @return owner The address of the token owner.\n\t/// @return blockNumber The blocknumber at which the last transfer of that id happened.\n\tfunction ownerAndLastTransferBlockNumberOf(uint256 id) internal view returns (address owner, uint256 blockNumber) {\n\t\treturn _ownerAndBlockNumberOf(id);\n\t}\n\n\tstruct OwnerData {\n\t\taddress owner;\n\t\tuint256 lastTransferBlockNumber;\n\t}\n\n\t/// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\n\t/// @param ids The list of token ids to check.\n\t/// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\n\tfunction ownerAndLastTransferBlockNumberList(uint256[] calldata ids)\n\t\texternal\n\t\tview\n\t\treturns (OwnerData[] memory ownersData)\n\t{\n\t\townersData = new OwnerData[](ids.length);\n\t\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\t\tuint256 data = _owners[ids[i]];\n\t\t\townersData[i].owner = address(uint160(data));\n\t\t\townersData[i].lastTransferBlockNumber = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n\t\t}\n\t}\n\n\t/// @notice Get the approved operator for a specific token.\n\t/// @param id The id of the token.\n\t/// @return The address of the operator.\n\tfunction getApproved(uint256 id) external view override returns (address) {\n\t\t(address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\t\tif (operatorEnabled) {\n\t\t\treturn _operators[id];\n\t\t} else {\n\t\t\treturn address(0);\n\t\t}\n\t}\n\n\t/// @notice Check if the sender approved the operator.\n\t/// @param owner The address of the owner.\n\t/// @param operator The address of the operator.\n\t/// @return isOperator The status of the approval.\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool isOperator) {\n\t\treturn _operatorsForAll[owner][operator];\n\t}\n\n\t/// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n\t/// @param from The sender of the token.\n\t/// @param to The recipient of the token.\n\t/// @param id The id of the token.\n\t/// @param data Additional data.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id,\n\t\tbytes memory data\n\t) public override {\n\t\t(address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\t\trequire(owner == from, \"NOT_OWNER\");\n\t\trequire(to != address(0), \"NOT_TO_ZEROADDRESS\");\n\t\trequire(to != address(this), \"NOT_TO_THIS\");\n\t\tif (msg.sender != from) {\n\t\t\trequire(\n\t\t\t\t(operatorEnabled && _operators[id] == msg.sender) || isApprovedForAll(from, msg.sender),\n\t\t\t\t\"UNAUTHORIZED_TRANSFER\"\n\t\t\t);\n\t\t}\n\t\t_safeTransferFrom(from, to, id, data);\n\t}\n\n\t/// @notice Check if the contract supports an interface.\n\t/// @param id The id of the interface.\n\t/// @return Whether the interface is supported.\n\tfunction supportsInterface(bytes4 id) public view virtual override returns (bool) {\n\t\t/// 0x01ffc9a7 is ERC165.\n\t\t/// 0x80ac58cd is ERC721\n\t\t/// 0x5b5e139f is for ERC721 metadata\n\t\treturn id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n\t}\n\n\t// TODO : function tokenURI(uint256 id) external view virtual returns (string memory);\n\n\tfunction _safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id,\n\t\tbytes memory data\n\t) internal {\n\t\t_transferFrom(from, to, id);\n\t\tif (to.isContract()) {\n\t\t\trequire(_checkOnERC721Received(msg.sender, from, to, id, data), \"ERC721_TRANSFER_REJECTED\");\n\t\t}\n\t}\n\n\tfunction _transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id\n\t) internal {\n\t\tunchecked {\n\t\t\t_balances[to]++;\n\t\t\tif (from != address(0)) {\n\t\t\t\t_balances[from]--;\n\t\t\t}\n\t\t}\n\t\t_owners[id] = (block.number << 160) | uint256(uint160(to));\n\t\temit Transfer(from, to, id);\n\t}\n\n\t/// @dev See approve.\n\tfunction _approveFor(\n\t\taddress owner,\n\t\tuint256 blockNumber,\n\t\taddress operator,\n\t\tuint256 id\n\t) internal override {\n\t\tif (operator == address(0)) {\n\t\t\t_owners[id] = (blockNumber << 160) | uint256(uint160(owner));\n\t\t} else {\n\t\t\t_owners[id] = OPERATOR_FLAG | (blockNumber << 160) | uint256(uint160(owner));\n\t\t\t_operators[id] = operator;\n\t\t}\n\t\temit Approval(owner, operator, id);\n\t}\n\n\t/// @dev See setApprovalForAll.\n\tfunction _setApprovalForAll(\n\t\taddress sender,\n\t\taddress operator,\n\t\tbool approved\n\t) internal override {\n\t\t_operatorsForAll[sender][operator] = approved;\n\n\t\temit ApprovalForAll(sender, operator, approved);\n\t}\n\n\t/// @dev Check if receiving contract accepts erc721 transfers.\n\t/// @param operator The address of the operator.\n\t/// @param from The from address, may be different from msg.sender.\n\t/// @param to The adddress we want to transfer to.\n\t/// @param id The id of the token we would like to transfer.\n\t/// @param _data Any additional data to send with the transfer.\n\t/// @return Whether the expected value of 0x150b7a02 is returned.\n\tfunction _checkOnERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 id,\n\t\tbytes memory _data\n\t) internal returns (bool) {\n\t\tbytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, id, _data);\n\t\treturn (retval == ERC721_RECEIVED);\n\t}\n\n\t/// @dev See ownerOf\n\tfunction _ownerOf(uint256 id) internal view returns (address owner) {\n\t\treturn address(uint160(_owners[id]));\n\t}\n\n\t/// @dev Get the owner and operatorEnabled status of a token.\n\t/// @param id The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return operatorEnabled Whether or not operators are enabled for this token.\n\tfunction _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n\t\tuint256 data = _owners[id];\n\t\towner = address(uint160(data));\n\t\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n\t}\n\n\t// @dev Get the owner and operatorEnabled status of a token.\n\t/// @param id The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return blockNumber the blockNumber at which the owner became the owner (last transfer).\n\tfunction _ownerAndBlockNumberOf(uint256 id) internal view override returns (address owner, uint256 blockNumber) {\n\t\tuint256 data = _owners[id];\n\t\towner = address(uint160(data));\n\t\tblockNumber = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n\t}\n}\n"
    },
    "src/ERC721/ERC4494/implementations/UsingERC4494PermitWithDynamicChainId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./UsingERC4494Permit.sol\";\n\nabstract contract UsingERC4494PermitWithDynamicChainId is UsingERC4494Permit, UsingERC712WithDynamicChainId {\n\tfunction DOMAIN_SEPARATOR() public view virtual override returns (bytes32) {\n\t\treturn _currentDomainSeparator();\n\t}\n}\n"
    },
    "src/Multicall/UsingMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract UsingMulticall {\n\tusing Address for address;\n\n\t// from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol\n\t/// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed.\n\t/// @dev The `msg.value` should not be trusted for any method callable from multicall.\n\t/// @param data The encoded function data for each of the calls to make to this contract.\n\t/// @return results The results from each of the calls passed in via data.\n\tfunction multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n\t\tresults = new bytes[](data.length);\n\t\tfor (uint256 i = 0; i < data.length; i++) {\n\t\t\t(bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n\t\t\tif (!success) {\n\t\t\t\t// Next 5 lines from https://ethereum.stackexchange.com/a/83577\n\t\t\t\tif (result.length < 68) revert();\n\t\t\t\tassembly {\n\t\t\t\t\tresult := add(result, 0x04)\n\t\t\t\t}\n\t\t\t\trevert(abi.decode(result, (string)));\n\t\t\t}\n\n\t\t\tresults[i] = result;\n\t\t}\n\t}\n}\n"
    },
    "src/ERC721/implementations/UsingExternalMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../../Guardian/libraries/Guarded.sol\";\n\ncontract UsingExternalMinter {\n\tevent MinterAdminSet(address newMinterAdmin);\n\tevent MinterSet(address newMinter);\n\n\t/// @notice minterAdmin can update the minter. At the time being there is 576 Bleeps but there is space for extra instrument and the upper limit is 1024.\n\t/// could be given to the DAO later so instrument can be added, the sale of these new bleeps could benenfit the DAO too and add new members.\n\taddress public minterAdmin;\n\n\t/// @notice address allowed to mint, allow the sale contract to be separated from the token contract that can focus on the core logic\n\t/// Once all 1024 potential bleeps (there could be less, at minimum there are 576 bleeps) are minted, no minter can mint anymore\n\taddress public minter;\n\n\tconstructor(address initialMinterAdmin) {\n\t\tif (initialMinterAdmin != address(0)) {\n\t\t\tminterAdmin = initialMinterAdmin;\n\t\t\temit MinterAdminSet(initialMinterAdmin);\n\t\t}\n\t}\n\n\t/**\n\t * @notice set the new minterAdmin that can set the minter for Bleeps\n\t * Can only be called by the current minter admin.\n\t */\n\tfunction setMinterAdmin(address newMinterAdmin) external {\n\t\trequire(msg.sender == minterAdmin || Guarded.isGuardian(msg.sender, newMinterAdmin), \"NOT_AUTHORIZED\");\n\t\tif (newMinterAdmin != minterAdmin) {\n\t\t\tminterAdmin = newMinterAdmin;\n\t\t\temit MinterAdminSet(newMinterAdmin);\n\t\t}\n\t}\n\n\t/**\n\t * @notice set the new minter that can mint\n\t * Can only be called by the minter admin.\n\t */\n\tfunction setMinter(address newMinter) external {\n\t\trequire(msg.sender == minterAdmin, \"NOT_AUTHORIZED\");\n\t\tif (minter != newMinter) {\n\t\t\tminter = newMinter;\n\t\t\temit MinterSet(newMinter);\n\t\t}\n\t}\n}\n"
    },
    "src/ERC2981/implementations/UsingGlobalRoyalties.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../interfaces/IERC2981.sol\";\nimport \"../../ERC165/UsingERC165Internal.sol\";\nimport \"../../Guardian/libraries/Guarded.sol\";\n\ncontract UsingGlobalRoyalties is IERC2981, UsingERC165Internal {\n\tevent RoyaltySet(address receiver, uint256 royaltyPer10Thousands);\n\tevent RoyaltyAdminSet(address newRoyaltyAdmin);\n\n\tstruct Royalty {\n\t\taddress receiver;\n\t\tuint96 per10Thousands;\n\t}\n\n\tRoyalty internal _royalty;\n\n\t/// @notice address allowed to set royalty parameters\n\taddress public royaltyAdmin;\n\n\t/// @param initialRoyaltyReceiver receiver of royalties\n\t/// @param imitialRoyaltyPer10Thousands amount of royalty in 10,000 basis point\n\t/// @param initialRoyaltyAdmin admin able to update the royalty receiver and rates\n\tconstructor(\n\t\taddress initialRoyaltyReceiver,\n\t\tuint96 imitialRoyaltyPer10Thousands,\n\t\taddress initialRoyaltyAdmin\n\t) {\n\t\tif (initialRoyaltyAdmin != address(0)) {\n\t\t\troyaltyAdmin = initialRoyaltyAdmin;\n\t\t\temit RoyaltyAdminSet(initialRoyaltyAdmin);\n\t\t}\n\n\t\t_royalty.receiver = initialRoyaltyReceiver;\n\t\t_royalty.per10Thousands = imitialRoyaltyPer10Thousands;\n\t\temit RoyaltySet(initialRoyaltyReceiver, imitialRoyaltyPer10Thousands);\n\t}\n\n\t/// @notice Called with the sale price to determine how much royalty is owed and to whom.\n\t/// @param //id - the token queried for royalty information.\n\t/// @param salePrice - the sale price of the token specified by id.\n\t/// @return receiver - address of who should be sent the royalty payment.\n\t/// @return royaltyAmount - the royalty payment amount for salePrice.\n\tfunction royaltyInfo(\n\t\tuint256, /*id*/\n\t\tuint256 salePrice\n\t) external view returns (address receiver, uint256 royaltyAmount) {\n\t\treceiver = _royalty.receiver;\n\t\troyaltyAmount = (salePrice * uint256(_royalty.per10Thousands)) / 10000;\n\t}\n\n\t/// @notice set a new royalty receiver and rate, Can only be set by the `royaltyAdmin`.\n\t/// @param newReceiver the address that should receive the royalty proceeds.\n\t/// @param royaltyPer10Thousands the share of the salePrice (in 1/10000) given to the receiver.\n\tfunction setRoyaltyParameters(address newReceiver, uint96 royaltyPer10Thousands) external {\n\t\trequire(msg.sender == royaltyAdmin, \"NOT_AUTHORIZED\");\n\t\trequire(royaltyPer10Thousands <= 50, \"ROYALTY_TOO_HIGH\");\n\t\tif (_royalty.receiver != newReceiver || _royalty.per10Thousands != royaltyPer10Thousands) {\n\t\t\t_royalty.receiver = newReceiver;\n\t\t\t_royalty.per10Thousands = royaltyPer10Thousands;\n\t\t\temit RoyaltySet(newReceiver, royaltyPer10Thousands);\n\t\t}\n\t}\n\n\t/**\n\t * @notice set the new royaltyAdmin that can change the royalties\n\t * Can only be called by the current royalty admin.\n\t */\n\tfunction setRoyaltyAdmin(address newRoyaltyAdmin) external {\n\t\trequire(msg.sender == royaltyAdmin || Guarded.isGuardian(msg.sender, newRoyaltyAdmin), \"NOT_AUTHORIZED\");\n\t\tif (royaltyAdmin != newRoyaltyAdmin) {\n\t\t\troyaltyAdmin = newRoyaltyAdmin;\n\t\t\temit RoyaltyAdminSet(newRoyaltyAdmin);\n\t\t}\n\t}\n\n\t/// @notice Check if the contract supports an interface.\n\t/// @param id The id of the interface.\n\t/// @return Whether the interface is supported.\n\tfunction supportsInterface(bytes4 id) public view virtual override(IERC165, UsingERC165Internal) returns (bool) {\n\t\treturn super.supportsInterface(id) || id == 0x2a55205a; /// 0x2a55205a is ERC2981 (royalty standard)\n\t}\n}\n"
    },
    "src/Guardian/implementations/UsingGuardian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ncontract UsingGuardian {\n\tevent GuardianSet(address newGuardian);\n\n\t// bytes32 GUARDIAN_SLOT = bytes32(uint256(keccak256('guardian')) - 1); // 0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27\n\n\tconstructor(address initialGuardian) {\n\t\tif (initialGuardian != address(0)) {\n\t\t\tassembly {\n\t\t\t\tsstore(0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27, initialGuardian)\n\t\t\t}\n\t\t\temit GuardianSet(initialGuardian);\n\t\t}\n\t}\n\n\t/// @notice guardian has some special vetoing power to guide the direction of the DAO. It can only remove rights from the DAO. It could be used to immortalize rules.\n\t/// For example: the royalty setup could be frozen.\n\tfunction guardian() external view returns (address g) {\n\t\tassembly {\n\t\t\tg := sload(0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27)\n\t\t}\n\t}\n\n\t/**\n\t * @notice set the new guardian that can freeze the other admins (except owner).\n\t * Can only be called by the current guardian.\n\t */\n\tfunction setGuardian(address newGuardian) external {\n\t\taddress currentGuardian;\n\t\tassembly {\n\t\t\tcurrentGuardian := sload(0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27)\n\t\t}\n\t\trequire(msg.sender == currentGuardian, \"NOT_AUTHORIZED\");\n\t\tif (currentGuardian != newGuardian) {\n\t\t\tassembly {\n\t\t\t\tsstore(0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27, newGuardian)\n\t\t\t}\n\t\t\temit GuardianSet(newGuardian);\n\t\t}\n\t}\n}\n"
    },
    "src/TheBleepMachine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n// _/\\/\\/\\/\\/\\/\\__/\\/\\________________________/\\/\\/\\/\\/\\____/\\/\\____________________________________________/\\/\\______/\\/\\__________________________/\\/\\________/\\/\\___________________________\n// _____/\\/\\______/\\/\\__________/\\/\\/\\________/\\/\\____/\\/\\__/\\/\\______/\\/\\/\\______/\\/\\/\\____/\\/\\/\\/\\________/\\/\\/\\__/\\/\\/\\__/\\/\\/\\________/\\/\\/\\/\\__/\\/\\________________/\\/\\/\\/\\______/\\/\\/\\___\n// _____/\\/\\______/\\/\\/\\/\\____/\\/\\/\\/\\/\\______/\\/\\/\\/\\/\\____/\\/\\____/\\/\\/\\/\\/\\__/\\/\\/\\/\\/\\__/\\/\\__/\\/\\______/\\/\\/\\/\\/\\/\\/\\______/\\/\\____/\\/\\________/\\/\\/\\/\\____/\\/\\____/\\/\\__/\\/\\__/\\/\\/\\/\\/\\_\n// _____/\\/\\______/\\/\\__/\\/\\__/\\/\\____________/\\/\\____/\\/\\__/\\/\\____/\\/\\________/\\/\\________/\\/\\/\\/\\________/\\/\\__/\\__/\\/\\__/\\/\\/\\/\\____/\\/\\________/\\/\\__/\\/\\__/\\/\\____/\\/\\__/\\/\\__/\\/\\_______\n// _____/\\/\\______/\\/\\__/\\/\\____/\\/\\/\\/\\______/\\/\\/\\/\\/\\____/\\/\\/\\____/\\/\\/\\/\\____/\\/\\/\\/\\__/\\/\\____________/\\/\\______/\\/\\__/\\/\\/\\/\\/\\____/\\/\\/\\/\\__/\\/\\__/\\/\\__/\\/\\/\\__/\\/\\__/\\/\\____/\\/\\/\\/\\_\n// _________________________________________________________________________________________/\\/\\_______________________________________________________________________________________________\n\n// The Bleep Machine Generates Music From Executing Ethereum Bytecode.\n\n// It is an implementation of Bytebeat on the EVM.\n//\n// Try the following:\n//\n// cast call --rpc-url https://rpc.bleeps.art machine.bleeps.eth \"WAV(bytes,uint256,uint256)(bytes)\" 0x808060081c9160091c600e1661ca98901c600f160217  0 100000 | xxd -r -p | aplay\n//\n// Note: this requires cast (see: https://github.com/foundry-rs) + aplay + xxd + a working ethereum rpc node (here: https://rpc.bleeps.art).\n//\n// This will execute the following formula: `t*(0xCA98>>(t>>9&14)&15)|t>>8` (taken from http://viznut.fi/texts-en/bytebeat_exploring_space.pdf)\n//\n// It will be executed 100,000 times with t starting at 0 and increasing by one on each iteration.\n//\n// This will produce a WAV file of 100,000 samples (8 bits, mono) at 8000 hz (or 12.5 seconds).\n\n// Copyright (C) 2022 Ronan Sandford\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.16;\n\nerror MusicByteCodeTooLarge();\nerror MusicContractCreationFailure();\nerror MusicExecutionFailure();\n\ncontract TheBleepMachine {\n\t/// @notice return the name of the contract\n\tfunction name() external pure returns (string memory) {\n\t\treturn \"The Bleep Machine\";\n\t}\n\n\t/// @notice Generates a WAV file (8 bits, 8000Hz, mono) by executing the EVM bytecode provided (`musicBytecode`).\n\t/// The time offset is the only element on the stack at each loop iteration.\n\t/// Such offset starts at `start` and is increased by one for each iteration.\n\t/// The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration.\n\t/// The loop is executed `length` times to generate `length` samples which compose the music generated.\n\t/// @param musicBytecode the EVM bytecode that the Bleep Machine will execute in a loop.\n\t/// @param start sample offset at which the music starts.\n\t/// @param length the number of samples to generate.\n\t/// @return WAV file (8 bits, 8000Hz, mono).\n\tfunction WAV(\n\t\tbytes memory musicBytecode,\n\t\tuint256 start,\n\t\tuint256 length\n\t) external returns (bytes memory) {\n\t\t// Create empty wav file of size `length` with proper header.\n\t\tbytes memory wavFile = _wavFile(length);\n\t\t// Generate the samples in it at offset 44 (header size)\n\t\t_generateAndwrite(musicBytecode, start, length, wavFile, 44);\n\t\treturn wavFile;\n\t}\n\n\t/// @notice Generates raw 8 bits samples by executing the EVM bytecode provided (`musicBytecode`).\n\t/// The time offset is the only element on the stack at each loop iteration.\n\t/// Such offset starts at `start` and is increased by one for each iteration.\n\t/// The code is expected to provide an 8 bits sample as the only element in the stack at the end of each iteration.\n\t/// The loop is executed `length` times to generate `length` samples which compose the music generated.\n\t/// @param musicBytecode the EVM bytecode that the Bleep Machine will execute in a loop.\n\t/// @param start sample offset at which the music starts.\n\t/// @param length the number of samples to generate.\n\t/// @return 8 bits samples buffer.\n\tfunction generate(\n\t\tbytes memory musicBytecode,\n\t\tuint256 start,\n\t\tuint256 length\n\t) external returns (bytes memory) {\n\t\t// Create empty bytes array of exact length\n\t\tbytes memory samples = new bytes(length);\n\t\t// Generate the samples in it\n\t\t_generateAndwrite(musicBytecode, start, length, samples, 0);\n\t\treturn samples;\n\t}\n\n\t/// @notice Generates a WAV file (8 bits, 8000Hz, mono) from contract's code at a specific address.\n\t/// @param addr address of any contract. Most will generate noises.\n\t/// @return WAV file (8 bits, 8000Hz, mono).\n\tfunction listenTo(address addr) external view returns (bytes memory) {\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(addr)\n\t\t}\n\t\tbytes memory buffer = _wavFile(size);\n\t\tassembly {\n\t\t\t// copy code in that buffer at pos 76 = 44 (wav header size) + 32 (where bytes size is stored)\n\t\t\textcodecopy(addr, add(buffer, 76), 0, size)\n\t\t}\n\t\treturn buffer;\n\t}\n\n\t// ----------------------------------------------------------------------------------------------------------------\n\t// INTERNAL\n\t// ----------------------------------------------------------------------------------------------------------------\n\n\t/// @dev generate sample data by executing the EVM bytecode provided (`musicBytecode`) and write it in buffer.\n\t/// It generates the data in the provided buffer (assumed to have the correct length already, see _wavFile)\n\t/// @param musicBytecode the EVM bytecode the Bleep Machine will execute in a loop.\n\t/// @param start sample offset at which the music starts.\n\t/// @param length the number of samples to generate.\n\t/// @param buffer buffer to write to\n\t/// @param offset offset to start writing to\n\tfunction _generateAndwrite(\n\t\tbytes memory musicBytecode,\n\t\tuint256 start,\n\t\tuint256 length,\n\t\tbytes memory buffer,\n\t\tuint256 offset\n\t) internal {\n\t\t// We create the contract from the music bytecode.\n\t\taddress executor = _create(musicBytecode);\n\n\t\tbool success;\n\t\tassembly {\n\t\t\t// We ask solidity for the pointer to free memory (not yet used)\n\t\t\tlet argsPointer := mload(0x40)\n\t\t\t// We then store at that position the arguments <start><length> (in 32 bytes, 128 bits each)\n\t\t\tmstore(argsPointer, or(shr(128, shl(128, start)), shl(128, length)))\n\t\t\t// We then make the call\n\t\t\t// and store the result in the existing buffer at pos = offset + 32\n\t\t\t// (the first 32 bytes store the length of the bytes array)\n\t\t\tsuccess := staticcall(gas(), executor, argsPointer, 32, add(buffer, add(offset, 32)), length)\n\t\t}\n\n\t\t// If there is any error, we revert.\n\t\tif (!success) {\n\t\t\trevert MusicExecutionFailure();\n\t\t}\n\t}\n\n\t/// @dev Creates a new contract that generate the music from a given start offset and length.\n\t/// @param musicBytecode the EVM bytecode the Bleep Machine will execute in a loop.\n\t/// @return executor address of the contract that will generate samples when executed.\n\tfunction _create(bytes memory musicBytecode) internal returns (address executor) {\n\t\t// This code generates a contract creation-code that loops over the provided `musicBytecode`.\n\n\t\t// 61006d600081600b8239f3 => simply copy the code after it.\n\t\t// Note that 006d will is overwritten below with the new length\n\n\t\t// 6000358060801b60801c806000529060801c6020525b => prepare the data\n\t\t// In particular it parses the call-data to extract the start and length parameters (Stored in 128bit each).\n\t\t// It then ensures that the starting time is on top of the stack before the loop starts.\n\t\t// The last `5b` is a JUMPDEST that will be jumped to at each iteration.\n\n\t\t// 6040519060ff16816060015360010180604052600051810190602051116015576020516060f3\n\t\t// => Performs the loop and when it ends (start + time >= length), it copy the generated buffer in return data.\n\n\t\tbytes memory executorCreation = bytes.concat(\n\t\t\thex\"61006d600081600b8239f36000358060801b60801c806000529060801c6020525b\",\n\t\t\tmusicBytecode,\n\t\t\thex\"6040519060ff16816060015360010180604052600051810190602051116015576020516060f3\"\n\t\t);\n\t\tuint256 len = musicBytecode.length;\n\n\t\t// We make sure the generated code length can be encoded in the PUSH2.\n\t\tuint256 codeLen;\n\t\tunchecked {\n\t\t\tcodeLen = 0x3C + len;\n\t\t}\n\t\tif (codeLen > 0xFFFF) {\n\t\t\trevert MusicByteCodeTooLarge();\n\t\t}\n\n\t\t// We store the generated creationCode length so that the creationCode work with its new length.\n\t\tassembly {\n\t\t\tmstore8(add(executorCreation, 33), shr(8, codeLen))\n\t\t\tmstore8(add(executorCreation, 34), and(codeLen, 0xFF))\n\t\t}\n\n\t\t// We create the contract.\n\t\tassembly {\n\t\t\texecutor := create(0, add(executorCreation, 32), mload(executorCreation))\n\t\t}\n\n\t\t// If there is any error, we revert.\n\t\tif (executor == address(0)) {\n\t\t\trevert MusicContractCreationFailure();\n\t\t}\n\t}\n\n\t/// @dev generate an empty WAV file of length `length`\n\t/// @param length the number of samples in the WAV file.\n\t/// @return wavFile : zeroed out WAV file with correct headers data.\n\tfunction _wavFile(uint256 length) internal pure returns (bytes memory wavFile) {\n\t\tunchecked {\n\t\t\twavFile = new bytes(length + 44); // 44 is the header size\n\t\t}\n\n\t\tassembly {\n\t\t\t// WAV file header, 8 bits, 8000Hz, mono, empty length.\n\t\t\tmstore(add(wavFile, 32), 0x524946460000000057415645666d74201000000001000100401f0000401f0000)\n\t\t\tmstore(add(wavFile, 64), 0x0100080064617461000000000000000000000000000000000000000000000000)\n\n\t\t\t// Top header length is length of data + 36 bytes.\n\t\t\t// More precisely: (4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)).\n\t\t\t// Where SubChunk1Size is 16 (for PCM) and SubChunk2Size is the length of the data.\n\t\t\tlet t := add(length, 36)\n\t\t\t// We write that length info in the top header (in little-endian).\n\t\t\tmstore8(add(wavFile, 36), and(t, 0xFF))\n\t\t\tmstore8(add(wavFile, 37), and(shr(8, t), 0xFF))\n\t\t\tmstore8(add(wavFile, 38), and(shr(16, t), 0xFF))\n\t\t\t// We also write the exact data length just before the data stream as per WAV file format spec (in little-endian).\n\t\t\tmstore8(add(wavFile, 72), and(length, 0xFF))\n\t\t\tmstore8(add(wavFile, 73), and(shr(8, length), 0xFF))\n\t\t\tmstore8(add(wavFile, 74), and(shr(16, length), 0xFF))\n\t\t}\n\t}\n}\n"
    },
    "src/Utils.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.16;\n\nlibrary Utils {\n\tfunction numLeadingZeroes(uint256 x) internal pure returns (uint256) {\n\t\tuint256 y;\n\t\tuint256 n = 256;\n\t\tunchecked {\n\t\t\ty = x >> 128;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 128;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 64;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 64;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 32;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 32;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 16;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 16;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 8;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 8;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 4;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 4;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 2;\n\t\t\tif (y != 0) {\n\t\t\t\tn = n - 2;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\ty = x >> 1;\n\t\t\tif (y != 0) return n - 2;\n\t\t}\n\n\t\treturn n - x;\n\t}\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/ERC721/implementations/ImplementingERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract ImplementingERC721Internal {\n\tfunction _ownerAndBlockNumberOf(uint256 id) internal view virtual returns (address owner, uint256 blockNumber);\n\n\tfunction _approveFor(\n\t\taddress owner,\n\t\tuint256 blockNumber,\n\t\taddress operator,\n\t\tuint256 id\n\t) internal virtual;\n\n\tfunction _setApprovalForAll(\n\t\taddress sender,\n\t\taddress operator,\n\t\tbool approved\n\t) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/ERC721/ERC4494/implementations/UsingERC4494Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../../implementations/ImplementingERC721Internal.sol\";\nimport \"../../../ERC165/UsingERC165Internal.sol\";\nimport \"../interfaces/IERC4494.sol\";\nimport \"../../../ERC712/implementations/UsingERC712WithDynamicChainId.sol\";\nimport \"../../../ERC712/implementations/ImplementingExternalDomainSeparator.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract UsingERC4494Permit is\n\tIERC4494,\n\tImplementingERC721Internal,\n\tUsingERC165Internal,\n\tImplementingExternalDomainSeparator,\n\tUsingERC712\n{\n\tbytes32 public constant PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH =\n\t\tkeccak256(\"PermitForAll(address spender,uint256 nonce,uint256 deadline)\");\n\n\tmapping(address => uint256) internal _userNonces;\n\n\t/// @notice return the account nonce, used for approvalForAll permit or other account related matter\n\t/// @param account the account to query\n\t/// @return nonce\n\tfunction nonces(address account) external view virtual returns (uint256 nonce) {\n\t\treturn _userNonces[account];\n\t}\n\n\t/// @notice return the token nonce, used for individual approve permit or other token related matter\n\t/// @param id token id to query\n\t/// @return nonce\n\tfunction nonces(uint256 id) public view virtual returns (uint256 nonce) {\n\t\t(address owner, uint256 blockNumber) = _ownerAndBlockNumberOf(id);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\t\treturn blockNumber;\n\t}\n\n\t/// @notice return the token nonce, used for individual approve permit or other token related matter\n\t/// @param id token id to query\n\t/// @return nonce\n\tfunction tokenNonces(uint256 id) external view returns (uint256 nonce) {\n\t\treturn nonces(id);\n\t}\n\n\tfunction permit(\n\t\taddress spender,\n\t\tuint256 tokenId,\n\t\tuint256 deadline,\n\t\tbytes memory sig\n\t) external {\n\t\trequire(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n\t\t(address owner, uint256 blockNumber) = _ownerAndBlockNumberOf(tokenId);\n\t\trequire(owner != address(0), \"NONEXISTENT_TOKEN\");\n\n\t\t// We use blockNumber as nonce as we already store it per tokens. It can thus act as an increasing transfer counter.\n\t\t// while technically multiple transfer could happen in the same block, the signed message would be using a previous block.\n\t\t// And the transfer would use then a more recent blockNumber, invalidating that message when transfer is executed.\n\t\t_requireValidPermit(owner, spender, tokenId, deadline, blockNumber, sig);\n\n\t\t_approveFor(owner, blockNumber, spender, tokenId);\n\t}\n\n\tfunction permitForAll(\n\t\taddress signer,\n\t\taddress spender,\n\t\tuint256 deadline,\n\t\tbytes memory sig\n\t) external {\n\t\trequire(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n\t\t_requireValidPermitForAll(signer, spender, deadline, _userNonces[signer]++, sig);\n\n\t\t_setApprovalForAll(signer, spender, true);\n\t}\n\n\t/// @notice Check if the contract supports an interface.\n\t/// @param id The id of the interface.\n\t/// @return Whether the interface is supported.\n\tfunction supportsInterface(bytes4 id) public view virtual override(IERC165, UsingERC165Internal) returns (bool) {\n\t\treturn\n\t\t\tsuper.supportsInterface(id) ||\n\t\t\tid == type(IERC4494).interfaceId ||\n\t\t\tid == type(IERC4494Alternative).interfaceId;\n\t}\n\n\tfunction DOMAIN_SEPARATOR()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride(IERC4494, ImplementingExternalDomainSeparator)\n\t\treturns (bytes32);\n\n\t// -------------------------------------------------------- INTERNAL --------------------------------------------------------------------\n\n\tfunction _requireValidPermit(\n\t\taddress signer,\n\t\taddress spender,\n\t\tuint256 id,\n\t\tuint256 deadline,\n\t\tuint256 nonce,\n\t\tbytes memory sig\n\t) internal view {\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR(),\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, spender, id, nonce, deadline))\n\t\t\t)\n\t\t);\n\t\trequire(SignatureChecker.isValidSignatureNow(signer, digest, sig), \"INVALID_SIGNATURE\");\n\t}\n\n\tfunction _requireValidPermitForAll(\n\t\taddress signer,\n\t\taddress spender,\n\t\tuint256 deadline,\n\t\tuint256 nonce,\n\t\tbytes memory sig\n\t) internal view {\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR(),\n\t\t\t\tkeccak256(abi.encode(PERMIT_FOR_ALL_TYPEHASH, spender, nonce, deadline))\n\t\t\t)\n\t\t);\n\t\trequire(SignatureChecker.isValidSignatureNow(signer, digest, sig), \"INVALID_SIGNATURE\");\n\t}\n}\n"
    },
    "src/ERC165/UsingERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract UsingERC165Internal {\n\tfunction supportsInterface(bytes4) public view virtual returns (bool) {\n\t\treturn false;\n\t}\n}\n"
    },
    "src/ERC721/ERC4494/interfaces/IERC4494.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\ninterface IERC4494 is IERC165 {\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/// @notice Allows to retrieve current nonce for token\n\t/// @param tokenId token id\n\t/// @return current token nonce\n\tfunction nonces(uint256 tokenId) external view returns (uint256);\n\n\t/// @notice function to be called by anyone to approve `spender` using a Permit signature\n\t/// @dev Anyone can call this to approve `spender`, even a third-party\n\t/// @param spender the actor to approve\n\t/// @param tokenId the token id\n\t/// @param deadline the deadline for the permit to be used\n\t/// @param signature permit\n\tfunction permit(\n\t\taddress spender,\n\t\tuint256 tokenId,\n\t\tuint256 deadline,\n\t\tbytes memory signature\n\t) external;\n}\n\ninterface IERC4494Alternative is IERC165 {\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/// @notice Allows to retrieve current nonce for token\n\t/// @param tokenId token id\n\t/// @return current token nonce\n\tfunction tokenNonces(uint256 tokenId) external view returns (uint256);\n\n\t/// @notice function to be called by anyone to approve `spender` using a Permit signature\n\t/// @dev Anyone can call this to approve `spender`, even a third-party\n\t/// @param spender the actor to approve\n\t/// @param tokenId the token id\n\t/// @param deadline the deadline for the permit to be used\n\t/// @param signature permit\n\tfunction permit(\n\t\taddress spender,\n\t\tuint256 tokenId,\n\t\tuint256 deadline,\n\t\tbytes memory signature\n\t) external;\n}\n"
    },
    "src/ERC712/implementations/UsingERC712WithDynamicChainId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./UsingERC712.sol\";\nimport \"./Named.sol\";\n\nabstract contract UsingERC712WithDynamicChainId is UsingERC712, Named {\n\tuint256 private immutable _deploymentChainId;\n\tbytes32 private immutable _deploymentDomainSeparator;\n\n\tconstructor() {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\t_deploymentChainId = chainId;\n\t\t_deploymentDomainSeparator = _calculateDomainSeparator(chainId);\n\t}\n\n\tfunction _currentDomainSeparator() internal view returns (bytes32) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\t// in case a fork happen, to support the chain that had to change its chainId, we compute the domain operator\n\t\treturn chainId == _deploymentChainId ? _deploymentDomainSeparator : _calculateDomainSeparator(chainId);\n\t}\n\n\t/// @dev Calculate the Domain Separator used to compute ERC712 hash\n\tfunction _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tkeccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"),\n\t\t\t\t\tkeccak256(bytes(name())),\n\t\t\t\t\tchainId,\n\t\t\t\t\taddress(this)\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\tfunction eip712Domain()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (\n\t\t\tbytes1,\n\t\t\tstring memory,\n\t\t\tstring memory,\n\t\t\tuint256,\n\t\t\taddress,\n\t\t\tbytes32,\n\t\t\tuint256[] memory\n\t\t)\n\t{\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\t// 0x0D == 01101 (name, , chainId, verifyingContract)\n\t\treturn (0x0D, name(), \"\", chainId, address(this), bytes32(0), new uint256[](0));\n\t}\n}\n"
    },
    "src/ERC712/implementations/ImplementingExternalDomainSeparator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract ImplementingExternalDomainSeparator {\n\tfunction DOMAIN_SEPARATOR() public view virtual returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.1) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "src/ERC712/implementations/UsingERC712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../interfaces/IERC5267.sol\";\n\nabstract contract UsingERC712 is IERC5267 {}\n"
    },
    "src/ERC712/implementations/Named.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract Named {\n\tfunction name() public view virtual returns (string memory);\n}\n"
    },
    "src/ERC712/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IERC5267 {\n\tfunction eip712Domain()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tbytes1 fields,\n\t\t\tstring memory name,\n\t\t\tstring memory version,\n\t\t\tuint256 chainId,\n\t\t\taddress verifyingContract,\n\t\t\tbytes32 salt,\n\t\t\tuint256[] memory extensions\n\t\t);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "src/Guardian/libraries/Guarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nlibrary Guarded {\n\tfunction isGuardian(address sender, address newValue) internal view returns (bool) {\n\t\taddress guardian;\n\t\tassembly {\n\t\t\tguardian := sload(0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27)\n\t\t}\n\t\treturn guardian != address(0) && sender == guardian && newValue == address(0);\n\t}\n\n\tfunction isGuardian(address sender, uint256 newValue) internal view returns (bool) {\n\t\taddress guardian;\n\t\tassembly {\n\t\t\tguardian := sload(0x8fbcb4375b910093bcf636b6b2f26b26eda2a29ef5a8ee7de44b5743c3bf9a27)\n\t\t}\n\t\treturn guardian != address(0) && sender == guardian && newValue == 0;\n\t}\n}\n"
    },
    "src/ERC2981/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\ninterface IERC2981 is IERC165 {\n\tfunction royaltyInfo(uint256 id, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}